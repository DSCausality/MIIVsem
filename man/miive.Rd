% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/miive.R
\name{miive}
\alias{miive}
\title{Model-implied instrumental variable (MIIV) estimation}
\usage{
miive(model = model, data = NULL, instruments = NULL, sample.cov = NULL,
  sample.mean = NULL, sample.nobs = NULL, sample.cov.rescale = TRUE,
  estimator = "2SLS", se = "standard", bootstrap = 1000L,
  est.only = FALSE, var.cov = FALSE, var.cov.estimator = "ML",
  miiv.check = TRUE, ordered = NULL)
}
\arguments{
\item{model}{A model specified using lavaan model syntax or a \code{\link{miivs}} object. See the \code{model} argument within the \code{\link[lavaan]{lavaanify}} function for more information.}

\item{data}{A data frame, list or environment or an object coercible by \code{as.data.frame} to data frame.}

\item{instruments}{A user-supplied list of valid MIIVs for each equation. See Example 2 below.}

\item{sample.cov}{Numeric matrix. A sample variance-covariance matrix. The rownames and colnames must contain the observed variable names.}

\item{sample.mean}{A sample mean vector.}

\item{sample.nobs}{Number of observations in the full data frame.}

\item{sample.cov.rescale}{If \code{TRUE}, the sample covariance matrix provided by the user is internally rescaled by multiplying it with a factor (N-1)/N.}

\item{estimator}{Options \code{"2SLS"} or \code{"GMM"} for estimating the model parameters. Default is \code{"2SLS"}.}

\item{se}{If "standard", conventional closed form standard errors are computed. If "boot" or "bootstrap", bootstrap standard errors are computed using standard bootstrapping.}

\item{bootstrap}{Number of bootstrap draws, if bootstrapping is used.}

\item{est.only}{If \code{TRUE}, only the coefficients are returned.}

\item{var.cov}{If \code{TRUE}, variance and covariance parameters are estimated.}

\item{var.cov.estimator}{The estimator to use for variance and covariance parameters.}

\item{ordered}{A vector of variable names to be treated as ordered factors in generating the polychoric correlation matrix.}

\item{miivs.check}{Options to turn off check for user-supplied instruments validity as MIIVs.}
}
\value{
A list of class \code{miive} containing the following elements:

\tabular{ll}{
\code{coefficients}\tab A named vector of parameter estimates\cr
\code{coefCov}\tab A variance-covariance matrix of the parameter estimates\cr
\code{residCov}\tab A residual variance-covariance matrix\cr
\code{eqn}\tab Equation level estimation resutls and statistics\cr
\code{call}\tab The matched call\cr
}
}
\description{
Estimate SEM models using model-implied instrumental variables (MIIVs).
}
\details{
\itemize{
\item{\code{model}} {
  A model specified using a subset of the uses a subset of the model syntax 
  employed by \pkg{lavaan}. See the \code{model} argument 
  within the \code{\link[lavaan]{lavaanify}} function for more information. 
  The following model syntax operators are currently supported: \code{"=~"},
  \code{"~"}, \code{"~~"} and \code{"*"}. See below for details 
  on default behavior descriptions of how to specify the scaling 
  indicator in latent variable models and impose equality constraints on the
  parameter estimates. 
  
  \strong{Example using Syntax Operators}
  
  In the model below, 'L1 \code{=~} Z1 + Z2 + Z3'  indicates the 
  latent variable L1 is measured by 3 indicators, Z1, Z2, and Z3. Likewise,
  L2 is measured by 3 indicators, Z4, Z5, and Z6. The statement
  'L1 \code{~} L2' specifies latent  variable L1 is regressed on latent 
  variable L2. 'Z1 \code{~~} Z2' specifies the error of indicator 
  Z2 is allowed to covary with the error of indicator Z3. The label
  L3 appended to Z3 and Z6 in the measurement model equations 
  constrains the factor loadings for Z3 and Z6 to equality. Additional 
  details on constraints see Equality Constraints  and Parameter 
  Restrictions.
  
  \preformatted{model <- '
     L1 =~ Z1 + Z2 + L3*Z3
     L2 =~ Z4 + Z5 + L3*Z6
     L1  ~ L2
     Z2 ~~ Z3
  '}
 
  \strong{Scaling Indicators}
  
  Following the \pkg{lavaan} model syntax, latent variables are defined 
  using the \code{=~} operator.  For first order factors, the scaling 
  indicator chosen is the first observed variable on the RHS of an 
  equation. For the model  below \code{Z1} would be chosen as the 
  scaling indicator for \code{L1} and \code{Z4} would be chosen as 
  the scaling indicator for \code{L2}.
  
  \preformatted{model <- '
     L1 =~ Z1 + Z2 + Z3
     L2 =~ Z4 + Z5 + Z6
  '}
  
  \strong{Higher-order Factor Models}
  
  For example, in the model below, the  scaling indicator for the 
  higher-order factor \code{H1} is taken to be \code{Z1}, the scaling 
  indicator that would have been assigned to the first lower-order 
  factor \code{L1}.
  
  \preformatted{model <- '
     H1 =~ L1 + L2 
     L1 =~ Z1 + Z2 + Z3
     L2 =~ Z4 + Z5 + Z6
  '}
  
  \strong{Equality Constraints and Parameter Restrictions}
  
  Within- and across-equation equality constraints on the factor loading
  and regression coefficients can be imposed directly in the model syntax. 
  To specify equality constraints between different parameters equivalent
  labels should be prepended to the variable name using the 
  \code{*} operator. For example, we could constrain the factor 
  loadings for two non-scaling indicators of latent factor \code{L1} to 
  equality using the following  model syntax.
  
  \preformatted{model <- '
     L1 =~ Z1 + B1*Z2 + B1*Z3
     L2 =~ Z4 + Z5 + Z6
  '}
  
  The factor loading and regression coefficients can also be constrained
  to specific numeric values in a similar fashion. Below we constrain
  the regression coefficient  of \code{L1} on \code{L2} to \code{1}.
  
  \preformatted{model <- '
     L1 =~ Z1 + Z2 + Z3
     L2 =~ Z4 + Z5 + Z6
     L3 =~ Z7 + Z8 + Z9
     L1  ~ 1*L2 + L3
  '}
  
  \strong{Model Defaults}
  
  In addition to those relationships specified in the model syntax 
  \pkg{MIIVsem} will automatically include the intercepts of any 
  observed or latent variables. Covariances among exogenous latent
  and observed  variables are included by default. 
  Where appropriate the covariances of latent and observed dependent 
  variables are also automatically included in the model specification.
  These defaults correspond to those used by \pkg{lavaan} and 
  \code{auto = TRUE}. 
  
  For example, in the model below the errors of Z1 and Z4 are allowed to 
  covary, in addition to all pairs of exogenous variables.
  
  \preformatted{model <- '
    Z1 ~ Z2 + Z3 
    Z4 ~ Z5 + Z6
  '}
  
  \strong{Invalid Specifications}
  
  Certain model specifications are not currently supported.  For example,
  the scaling indicator of a latent variable is not permitted to
  cross-load on another latent variable. For example, in the model below
  \code{Z1}, the scaling indicator for L1, cross-loads on the latent 
  variable \code{L2}. Executing a search on the model below will 
  result in the warning: \emph{miivs: scaling indicators with a factor 
  complexity greater than 1 are not currently supported}.
  
  \preformatted{model <- '
    L1 =~ Z1 + Z2 + Z3
    L2 =~ Z4 + Z5 + Z6 + Z1
  '}
  
  }
  
  \item{\code{data}} {
  A data.frame containing all of the observed variables specified in the
  model syntax. 
  }
  
  \item{\code{instruments}} {

  Using the \code{instruments} option you can specify the MIIVs directly 
  for each equation in the model. To utilize this option you must first 
  define a list of instruments using the syntax displayed below. Here,
  the dependent variable for each equation is listed on the LHS of the
  \code{"~"} operator. In the case of latent variable equations, the
  dependent variable is the scaling indicator associated with that
  variable. The instruments are then given on the RHS, seperated
  by \code{"+"} signs. For example, 
  
  \preformatted{myInstruments <- '
     y1 ~ z1 + z2 + z3
     y2 ~ z4 + z5
  '
  }
    
  After this list is defined, set the \code{instruments} argument equal to 
  the name of the list of instruments (e.g. \code{myInstruments}). 
  Note, that \code{instruments} are specified for an equation, 
  and not for a specific endogenous variable. If only a subset of dependent
  variables are listed in the instruments argument, only those  equations 
  will be estimated.  If external or auxilliary instruments (instruments 
  not otherwise included in the model) the \code{miivs.check} argument 
  should be set to \code{FALSE}.
  }
  
  \item{\code{sample.cov}} {
  The user may provide a sample covariance matrix in place of raw data.
  If \code{sample.cov} is not \code{NULL} the user must also supply a
  vector of sample means (\code{sample.mean}) as well as the number of 
  observations (\code{sample.nobs}) from which the means and covariances 
  were calculated.  Currently, \pkg{MIIVsem} does not support bootstrap 
  standard errors or polychoric instrumental variable esimtation when
  the sample moments are used in place of raw data.  
  }
  
 \item{\code{se}} {
  When \code{se} is set to \code{"boot"} or \code{"bootstrap"} standard 
  errors are computed using the pairs bootstrap. The standard errors 
  are based on the standard deviation of successful bootstrap replications.  
  The \code{z-value} and \code{P(>|z|)} assume the ratio of the coefficient 
  estimate to the bootstrap standard deviation approximates a normal 
  distribution.  Note, the Sargan test statistic is calculated from the 
  original sample and is not a bootstrap-based estimate.
  }
}
}
\examples{
# Example 1

bollen1989a_model <- '

    Eta1 =~ y1 + y2  + y3  + y4  
    Eta2 =~ y5 + y6  + y7  + y8    
    Xi1  =~ x1 + x2 + x3 

    Eta1 ~ Xi1  
    Eta2 ~ Xi1 
    Eta2 ~ Eta1 

    y1   ~~ y5
    y2   ~~ y4
    y2   ~~ y6
    y3   ~~ y7
    y4   ~~ y8
    y6   ~~ y8 

  '

miive(model = bollen1989a_model, data = bollen1989a)
# Example 2

bollen1989a_model <- '

    Eta1 =~ y1 + y2  + y3  + y4  
    Eta2 =~ y5 + y6  + y7  + y8    
    Xi1  =~ x1 + x2 + x3 

    Eta1 ~ Xi1  
    Eta2 ~ Xi1 
    Eta2 ~ Eta1 

    y1   ~~ y5
    y2   ~~ y4
    y2   ~~ y6
    y3   ~~ y7
    y4   ~~ y8
    y6   ~~ y8 
'

my_instruments <- ' 
    y1 ~ x2 + x3                            
    y5 ~ y2 + y3 + y4 + x2              
    y2 ~ y3 + y7 + y8 + x2           
    y3 ~ y2 + y4 + y6 + y8        
    y4 ~ y3 + y6           
    y6 ~ y3 + y4 + y7 + x2            
    y7 ~ y2 + y4 + y6 + y8       
    y8 ~ y2 + y3 + y7 + x2          
    x2 ~ y1 + y5 + y2 + y3 + y4 + y6
    x3 ~ y1 + y5 + y2 + y3 + y4 + y6
'

miive(model = bollen1989a_model, 
      data = bollen1989a, 
      instruments = my_instruments)
# Example 3

bollen1989a_model_r <- '

    Eta1 =~ y1 + l2*y2  + l3*y3  + l4*y4  
    Eta2 =~ y5 + l2*y6  + l3*y7  + l4*y8    
    Xi1  =~ x1 + x2 + 0.5*x3 

    Eta1 ~ Xi1  
    Eta2 ~ Xi1 
    Eta2 ~ Eta1 

    y1   ~~ y5
    y2   ~~ y4
    y2   ~~ y6
    y3   ~~ y7
    y4   ~~ y8
    y6   ~~ y8

'

miive(model = bollen1989a_model_r, data = bollen1989a)
}
\references{
Bollen, K. A. 1996.	An	Alternative	2SLS Estimator	for	Latent	
Variable	Models.	\emph{Psychometrika}, 61, 109-121.

Bollen,	K. A. 2001.	Two-stage	Least	Squares	and	Latent	Variable	Models:	
Simultaneous	Estimation	and	Robustness	to	Misspecifications.
In	R.	Cudeck,	S.	Du	Toit,	and	D.	Sorbom	(Eds.),	Structural	
Equation	Modeling:	Present	and	Future,	A	Festschrift	in	Honor	of	Karl	
Joreskog	(pp. 119-138).	Lincoln,	IL: Scientific	Software.
}
\seealso{
\link{MIIVsem}{miivs}
}
